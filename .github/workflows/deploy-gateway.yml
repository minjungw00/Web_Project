name: deploy-gateway

on:
  workflow_dispatch:
    inputs:
      nginx_tag:
        description: "nginx 이미지 태그 (미지정 시 latest)"
        required: false
        default: "latest"
      force_recreate:
        description: "컨테이너 강제 재생성 여부 (true/false)"
        required: false
        default: "false"
  workflow_call:
    inputs:
      nginx_tag:
        description: "nginx 이미지 태그"
        type: string
        required: false
        default: "latest"
      force_recreate:
        description: "컨테이너 강제 재생성 여부"
        type: string
        required: false
        default: "false"

jobs:
  deploy-gateway:
    if: ${{ github.actor == github.repository_owner || github.event_name == 'workflow_call' }}
    runs-on: ubuntu-latest
    env:
      DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
      DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
      DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
      DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
      NGINX_MONITORING_HTPASSWD_PROD_BASE64: ${{ secrets.NGINX_MONITORING_HTPASSWD_PROD_BASE64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Upload gateway compose file to server
        uses: appleboy/scp-action@v1
        with:
          host: ${{ env.DEPLOY_HOST }}
          username: ${{ env.DEPLOY_USER }}
          key: ${{ env.DEPLOY_SSH_KEY }}
          port: ${{ env.DEPLOY_PORT }}
          source: infra/gateway/docker-compose.gateway.prod.yml
          target: ~/srv/web_project/gateway/
          strip_components: 2

      - name: Upload gateway nginx config to server
        uses: appleboy/scp-action@v1
        with:
          host: ${{ env.DEPLOY_HOST }}
          username: ${{ env.DEPLOY_USER }}
          key: ${{ env.DEPLOY_SSH_KEY }}
          port: ${{ env.DEPLOY_PORT }}
          source: infra/gateway/nginx/*.conf,infra/gateway/nginx/.env.production,infra/gateway/nginx/certbot-issue.sh
          target: ~/srv/web_project/gateway/
          strip_components: 2

      - name: Deploy gateway
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.DEPLOY_HOST }}
          username: ${{ env.DEPLOY_USER }}
          key: ${{ env.DEPLOY_SSH_KEY }}
          port: ${{ env.DEPLOY_PORT }}
          envs: NGINX_MONITORING_HTPASSWD_PROD_BASE64
          script: |
            set -euo pipefail
            ROOTDIR="$HOME/srv/web_project"
            WORKDIR="$ROOTDIR/gateway"
            mkdir -p "$WORKDIR"
            cd "$WORKDIR"

            # Set nginx tag
            export NGINX_TAG="${{ inputs.nginx_tag }}"

            # Build merged env for compose variable expansion: root ../.env.server + stack .env.gateway.prod (if present)
            ROOT_ENV="../.env.server"
            if [ -f "../.env.server.prod" ]; then
              ROOT_ENV="../.env.server.prod"
            fi
            STACK_ENV=".env.gateway.prod"
            MERGED_ENV=".env.merged"
            {
              if [ -f "$ROOT_ENV" ]; then sed -e '/^\s*#/d' -e '/^\s*$/d' "$ROOT_ENV"; fi
              if [ -f "$STACK_ENV" ]; then sed -e '/^\s*#/d' -e '/^\s*$/d' "$STACK_ENV"; fi
            } > "$MERGED_ENV"
            chmod 600 "$MERGED_ENV" 2>/dev/null || true

            normalize_value() {
              local str="$1"
              str="${str#"${str%%[![:space:]]*}"}"
              str="${str%"${str##*[![:space:]]}"}"
              str="${str%\"}"
              str="${str#\"}"
              str="${str%\'}"
              str="${str#\'}"
              printf '%s' "$str"
            }

            get_env_from_file() {
              local key="$1" default_value="$2" file_path="$3" line value
              line=$(grep -E "^[[:space:]]*${key}=" "$file_path" | tail -n1 || true)
              if [ -n "$line" ]; then
                value="${line#*=}"
                value="$(normalize_value "$value")"
              else
                value=""
              fi
              if [ -z "$value" ]; then
                value="$default_value"
              fi
              printf '%s' "$value"
            }

            is_path_like() {
              local candidate="$1"
              if [ -z "$candidate" ]; then
                return 1
              fi
              case "$candidate" in
                /*|./*|../*|~*|?:/*|*/*|*\\*) return 0 ;;
              esac
              return 1
            }

            resolve_nginx_logs_volume() {
              local raw
              raw="$(get_env_from_file "NGINX_LOGS_MOUNT" "nginx-logs" "$MERGED_ENV")"
              if is_path_like "$raw"; then
                printf '%s' ""
              elif [ "$raw" = "nginx-logs" ]; then
                printf '%s' "web_project_nginx-logs"
              else
                printf '%s' "$raw"
              fi
            }

            ensure_volume_if_needed() {
              local volume_name="$1"
              if [ -z "$volume_name" ]; then
                return 0
              fi
              if ! docker volume inspect "$volume_name" >/dev/null 2>&1; then
                echo "[deploy-gateway] Creating volume: $volume_name"
                docker volume create "$volume_name" >/dev/null
              fi
            }

            NGINX_LOGS_VOLUME="$(resolve_nginx_logs_volume)"
            ensure_volume_if_needed "$NGINX_LOGS_VOLUME"

            export SERVER_ROOT="$ROOTDIR"

            HTPASSWD_UPDATED=0
            FORCE_RECREATE=0

            FORCE_RECREATE_INPUT="${{ inputs.force_recreate }}"
            if [ -n "$FORCE_RECREATE_INPUT" ]; then
              FORCE_RECREATE_NORMALIZED=$(printf '%s' "$FORCE_RECREATE_INPUT" | tr '[:upper:]' '[:lower:]')
              case "$FORCE_RECREATE_NORMALIZED" in
                true|1|yes|on)
                  FORCE_RECREATE=1
                  ;;
              esac
            fi

            sync_monitoring_htpasswd() {
              local b64="${NGINX_MONITORING_HTPASSWD_PROD_BASE64:-}"
              local target="$WORKDIR/nginx/monitoring.htpasswd.prod"
              if [ -z "$b64" ] || [ "$b64" = "***" ]; then
                return 0
              fi
              mkdir -p "$(dirname "$target")"
              local tmp="${target}.tmp"
              printf '%s' "$b64" | base64 -d > "$tmp"
              if [ ! -f "$target" ] || ! cmp -s "$tmp" "$target"; then
                install -m 644 "$tmp" "$target"
                HTPASSWD_UPDATED=1
                echo "[deploy-gateway] monitoring.htpasswd synced from secret"
              fi
              rm -f "$tmp"
            }

            sync_monitoring_htpasswd

            detect_active_backend() {
              for candidate in green blue; do
                local cid status
                cid=$(docker ps --filter "name=web_project-application-backend-${candidate}" --filter "status=running" -q | head -n1 || true)
                if [ -n "$cid" ]; then
                  status=$(docker inspect -f '{{.State.Health.Status}}' "$cid" 2>/dev/null || echo "")
                  case "$status" in
                    healthy|"")
                      echo "$candidate"
                      return 0
                      ;;
                  esac
                fi
              done
              return 1
            }

            update_nginx_backend_host() {
              local color="$1" env_file="$WORKDIR/nginx/.env.production"
              [ -n "$color" ] || return 0
              if [ ! -f "$env_file" ]; then
                echo "[deploy-gateway] warning: nginx env file not found: $env_file" >&2
                return 0
              fi
              local tmp="$env_file.tmp"
              if grep -q '^NGINX_BACKEND_HOST=' "$env_file" 2>/dev/null; then
                sed -E "s/^NGINX_BACKEND_HOST=.*/NGINX_BACKEND_HOST=backend-${color}/" "$env_file" > "$tmp"
              else
                cat "$env_file" > "$tmp"
                printf '\nNGINX_BACKEND_HOST=backend-%s\n' "$color" >> "$tmp"
              fi
              install -m 600 "$tmp" "$env_file"
              rm -f "$tmp"
              echo "[deploy-gateway] NGINX_BACKEND_HOST updated to backend-${color}"
            }

            ACTIVE_BACKEND_COLOR=$(detect_active_backend || true)
            if [ -z "$ACTIVE_BACKEND_COLOR" ]; then
              echo "[deploy-gateway] warning: active backend color could not be determined; keeping existing NGINX_BACKEND_HOST" >&2
            fi
            update_nginx_backend_host "$ACTIVE_BACKEND_COLOR"

            # Pull new image
            docker compose --env-file "$MERGED_ENV" -f docker-compose.gateway.prod.yml pull

            # Deploy with zero-downtime (force recreate if secrets changed)
            if [ "$HTPASSWD_UPDATED" = "1" ] || [ "$FORCE_RECREATE" = "1" ]; then
              if [ "$FORCE_RECREATE" = "1" ]; then
                echo "[deploy-gateway] Force recreate flag enabled"
              fi
              docker compose --env-file "$MERGED_ENV" -f docker-compose.gateway.prod.yml up -d --force-recreate
            else
              docker compose --env-file "$MERGED_ENV" -f docker-compose.gateway.prod.yml up -d
            fi

            # Wait for health check
            echo "Waiting for nginx to be healthy..."
            for i in $(seq 1 30); do
              CID=$(docker compose --env-file "$MERGED_ENV" -f docker-compose.gateway.prod.yml ps -q nginx || true)
              if [ -n "$CID" ]; then
                STATUS=$(docker inspect -f '{{.State.Health.Status}}' "$CID" 2>/dev/null || echo "unknown")
                if [ "$STATUS" = "healthy" ]; then
                  echo "Gateway is healthy!"
                  rm -f "$MERGED_ENV"
                  exit 0
                fi
                if [ "$STATUS" = "unhealthy" ]; then
                  echo "Gateway reported unhealthy status" >&2
                  break
                fi
              fi
              echo "Attempt $i/30: waiting..."
              sleep 2
            done

            echo "Gateway health check failed!"
            docker compose --env-file "$MERGED_ENV" -f docker-compose.gateway.prod.yml logs nginx
            rm -f "$MERGED_ENV"
            exit 1
